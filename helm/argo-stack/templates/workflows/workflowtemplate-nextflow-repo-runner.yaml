apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: nextflow-repo-runner
  namespace: {{ .Values.namespaces.argo }}
  labels:
    app.kubernetes.io/name: argo-stack
  annotations:
    helm.sh/hook: post-install,post-upgrade
    helm.sh/hook-weight: "10"
    helm.sh/hook-delete-policy: before-hook-creation
spec:
  entrypoint: run-nextflow
  {{- if .Values.events.github.commitStatus.enabled }}
  onExit: exit-handler
  {{- end }}
  arguments:
    parameters:
      - name: repo-name
        description: "Repository name or identifier for accessing repo-specific secrets."
      - name: repo-url
        description: "Git repo containing the Nextflow pipeline."
      - name: revision
        description: "Git revision (branch, tag, or SHA) to run."
        value: "main"
      - name: pipeline-file
        description: "Nextflow pipeline entry point file (e.g., main.nf, workflow.nf, pipeline.nf)."
        value: "main.nf"
      - name: work-dir
        description: "Work directory inside the container."
        value: "/workspace"
      - name: artifact-bucket
        description: "Artifact bucket name (from RepoRegistration.spec.artifactBucket.bucket)."
      - name: artifact-endpoint
        description: "Artifact S3 endpoint hostname/URL."
      - name: artifact-region
        description: "Artifact S3 region."
      # GitHub event data for commit status updates
      - name: github-owner
        description: "GitHub repository owner (extracted from event)."
        value: ""
      - name: github-repo
        description: "GitHub repository name (extracted from event)."
        value: ""
      - name: commit-sha
        description: "Git commit SHA (extracted from push event)."
        value: ""

  templates:
    - name: run-nextflow
      metadata:
        annotations:
          workflows.argoproj.io/description: |
            Run a Nextflow pipeline from a Git repo using S3-backed
            work and artifact storage derived from RepoRegistration.
      container:
        image: nextflow-runner:latest
        workingDir: "{{ "{{workflow.parameters.work-dir}}" }}"
        command: ["/bin/sh", "-c"]
        args:
          - |
            set -euo pipefail
            echo "Cloning repo: {{ "{{workflow.parameters.repo-url}}" }}"
            git clone {{ "{{workflow.parameters.repo-url}}" }} repo
            cd repo
            git checkout {{ "{{workflow.parameters.revision}}" }}

            echo "Configuring S3 environment for artifacts..."
            echo "Artifact bucket: {{ "{{workflow.parameters.artifact-bucket}}" }}"

            # Configure Nextflow to use S3 work directory
            export NXF_WORK="s3://{{ "{{workflow.parameters.artifact-bucket}}" }}/work"
            export NXF_S3_ENDPOINT="{{ "{{workflow.parameters.artifact-endpoint}}" }}"
            export NXF_S3_REGION="{{ "{{workflow.parameters.artifact-region}}" }}"

            echo "Running Nextflow pipeline..."
            nextflow run {{ "{{workflow.parameters.pipeline-file}}" }} -with-report report.html -with-trace -with-timeline timeline.html

        env:
          - name: NXF_HOME
            value: /workspace/.nextflow
          - name: AWS_ACCESS_KEY_ID
            valueFrom:
              secretKeyRef:
                name: s3-credentials-{{ "{{workflow.parameters.repo-name}}" }}
                key: AWS_ACCESS_KEY_ID
          - name: AWS_SECRET_ACCESS_KEY
            valueFrom:
              secretKeyRef:
                name: s3-credentials-{{ "{{workflow.parameters.repo-name}}" }}
                key: AWS_SECRET_ACCESS_KEY

    {{- if .Values.events.github.commitStatus.enabled }}
    # Exit handler to post commit status to GitHub
    - name: exit-handler
      metadata:
        annotations:
          workflows.argoproj.io/description: |
            Post workflow status back to GitHub commit.
            Runs on workflow completion (success or failure).
      script:
        image: {{ .Values.events.github.commitStatus.image | default "alpine/curl:latest" }}
        command: ["/bin/sh"]
        source: |
          #!/bin/sh
          set -e

          # Get workflow status
          WORKFLOW_STATUS="{{ "{{workflow.status}}" }}"
          WORKFLOW_NAME="{{ "{{workflow.name}}" }}"
          
          # Get GitHub parameters
          OWNER="{{ "{{workflow.parameters.github-owner}}" }}"
          REPO="{{ "{{workflow.parameters.github-repo}}" }}"
          SHA="{{ "{{workflow.parameters.commit-sha}}" }}"

          # Skip if required parameters are missing
          if [ -z "$OWNER" ] || [ -z "$REPO" ] || [ -z "$SHA" ]; then
            echo "Skipping GitHub status update - missing parameters"
            echo "Owner: $OWNER, Repo: $REPO, SHA: $SHA"
            exit 0
          fi

          # Map Argo workflow status to GitHub status
          case "$WORKFLOW_STATUS" in
            Succeeded)
              STATE="success"
              DESCRIPTION="✅ Workflow completed successfully"
              ;;
            Failed|Error)
              STATE="failure"
              DESCRIPTION="❌ Workflow failed"
              ;;
            *)
              STATE="error"
              DESCRIPTION="⚠️ Workflow ended with status: $WORKFLOW_STATUS"
              ;;
          esac

          # Build target URL (link to workflow in Argo UI)
          ARGO_SERVER_URL="${ARGO_SERVER_URL:-}"
          if [ -n "$ARGO_SERVER_URL" ]; then
            TARGET_URL="${ARGO_SERVER_URL}/workflows/{{ "{{workflow.namespace}}" }}/${WORKFLOW_NAME}"
          else
            TARGET_URL=""
          fi

          # GitHub API endpoint
          API_URL="https://api.github.com/repos/${OWNER}/${REPO}/statuses/${SHA}"

          # Build JSON payload
          if [ -n "$TARGET_URL" ]; then
            PAYLOAD="{\"state\":\"${STATE}\",\"target_url\":\"${TARGET_URL}\",\"description\":\"${DESCRIPTION}\",\"context\":\"argo-workflows\"}"
          else
            PAYLOAD="{\"state\":\"${STATE}\",\"description\":\"${DESCRIPTION}\",\"context\":\"argo-workflows\"}"
          fi

          # Display short SHA (portable approach)
          SHORT_SHA=$(echo "$SHA" | cut -c1-7)
          echo "Posting status to GitHub commit: $SHORT_SHA"
          echo "  State: $STATE"
          echo "  Description: $DESCRIPTION"
          if [ -n "$TARGET_URL" ]; then
            echo "  Target URL: $TARGET_URL"
          fi

          # Post status to GitHub (write response body to temp file for reliable parsing)
          TEMP_BODY=$(mktemp)
          chmod 600 "$TEMP_BODY"
          HTTP_CODE=$(curl -s -o "$TEMP_BODY" -w '%{http_code}' -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            "$API_URL")
          BODY=$(cat "$TEMP_BODY")
          rm -f "$TEMP_BODY"

          # Check for success (GitHub returns 201 for created status)
          case "$HTTP_CODE" in
            200|201)
              echo "✅ Status posted successfully (HTTP $HTTP_CODE)"
              ;;
            *)
              echo "❌ Failed to post status (HTTP $HTTP_CODE)"
              echo "Response: $BODY"
              # Don't fail the exit handler on status post failure
              ;;
          esac
        env:
          - name: GITHUB_TOKEN
            valueFrom:
              secretKeyRef:
                name: {{ .Values.events.github.commitStatus.secretName | default "github-secret" }}
                key: {{ .Values.events.github.commitStatus.secretKey | default "token" }}
          {{- if .Values.events.github.commitStatus.argoServerUrl }}
          - name: ARGO_SERVER_URL
            value: {{ .Values.events.github.commitStatus.argoServerUrl | quote }}
          {{- end }}
    {{- end }}
