name: Nextflow Workflow CI (kind + Argo Workflows)

on:
  pull_request:
    paths:
      - 'helm/**'
      - 'authz-adapter/**'
      - '.github/workflows/ci-nextflow.yaml'
      - 'test-workflows/**'
  push:
    branches:
      - main
      - feature/*
      - debug/*
    paths:
      - 'helm/**'
      - 'authz-adapter/**'
      - '.github/workflows/ci-nextflow.yaml'
      - 'test-workflows/**'

env:
  KIND_CLUSTER_NAME: nextflow-test
  KUBECONFIG: /tmp/kubeconfig

jobs:
  nextflow-workflow-test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Setup Docker
        run: |
          sudo systemctl start docker
          sudo chmod 666 /var/run/docker.sock

      - name: Create kind config file
        run: |
          cat > kind-config.yaml << 'EOF'
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
            kubeadmConfigPatches:
            - |
              kind: InitConfiguration
              nodeRegistration:
                kubeletExtraArgs:
                  node-labels: "ingress-ready=true"
            extraPortMappings:
            - containerPort: 80
              hostPort: 80
              protocol: TCP
            - containerPort: 443
              hostPort: 443
              protocol: TCP
            - containerPort: 2746
              hostPort: 2746
              protocol: TCP
          EOF

      - name: Setup kind
        uses: helm/kind-action@v1.8.0
        with:
          cluster_name: ${{ env.KIND_CLUSTER_NAME }}
          config: kind-config.yaml

      - name: Verify kind cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          kubectl get pods -A

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.15.3

      - name: Add chart repositories
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update

      - name: Install NGINX Ingress Controller
        run: |
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace \
            --set controller.service.type=NodePort \
            --set controller.admissionWebhooks.enabled=false \
            --wait --timeout=5m

      - name: Build Helm dependencies
        run: |
          helm dependency build helm/argo-stack

      - name: Install Argo Stack with test values
        run: |
          # Create test values for CI
          cat > ci-nextflow-values.yaml << EOF
          # Namespace configuration
          namespaces:
            argo: argo-workflows
            security: authz-security
            
          # Ingress configuration
          ingress:
            argoWorkflows:
              enabled: true
              host: localhost
              tls:
                enabled: false
          
          # Auth configuration for testing
          ingressAuth:
            enabled: false  # Disable for initial testing
            
          # Argo Workflows configuration
          argo-workflows:
            controller:
              persistence:
                connectionPool:
                  maxIdleConns: 100
              resources:
                requests:
                  memory: "128Mi"
                  cpu: "100m"
                limits:
                  memory: "512Mi"
                  cpu: "500m"
            server:
              extraArgs:
                - --auth-mode=server
                - --secure=false
              resources:
                requests:
                  memory: "128Mi"
                  cpu: "100m"
                limits:
                  memory: "512Mi"
                  cpu: "500m"
          
          # AuthZ Adapter configuration
          authzAdapter:
            enabled: true
            image:
              repository: python
              tag: "3.12-slim"
              pullPolicy: Always
            env:
              FENCE_BASE: "https://fake-fence.example.com/user"
              HTTP_TIMEOUT: "5.0"
            resources:
              requests:
                memory: "64Mi"
                cpu: "50m"
              limits:
                memory: "256Mi"
                cpu: "200m"
          
          # ArgoCD configuration (optional for workflow testing)
          argo-cd:
            server:
              resources:
                requests:
                  memory: "128Mi"
                  cpu: "100m"
                limits:
                  memory: "512Mi"
                  cpu: "500m"
          EOF

          # create namespace if not exists
          # kubectl get namespace argocd || kubectl create namespace argocd
          # kubectl label namespace argocd app.kubernetes.io/managed-by=Helm --overwrite

          # Render the Helm template
          helm template argo-stack helm/argo-stack \
            --create-namespace \
            --values ci-nextflow-values.yaml \
            --namespace argocd \
            --wait


          # Install the stack
          # --values ci-nextflow-values.yaml \
          helm upgrade --install argo-stack helm/argo-stack \
            --namespace argocd \
            --wait --timeout=10m

      - name: Wait for Argo Workflows to be ready
        run: |
          echo "Waiting for Argo Workflows controller..."
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argo-workflows-controller \
            -n argo-workflows --timeout=300s
          
          echo "Waiting for Argo Workflows server..."
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argo-workflows-server \
            -n argo-workflows --timeout=300s
          
          echo "Checking pod status..."
          kubectl get pods -n argo-workflows
          kubectl get pods -n authz-security || true

      - name: Setup port forwarding for Argo Workflows
        run: |
          kubectl port-forward -n argo-workflows svc/argo-workflows-server 2746:2746 &
          sleep 10
          
          # Test connectivity
          curl -f http://localhost:2746/ || true

      - name: Install Python dependencies for testing
        run: |
          pip install requests pyyaml kubernetes

      - name: Create Nextflow hello world workflow
        run: |
          mkdir -p test-workflows
          cat > test-workflows/nextflow-hello-world.yaml << 'EOF'
          apiVersion: argoproj.io/v1alpha1
          kind: Workflow
          metadata:
            generateName: nextflow-hello-world-
            namespace: argo-workflows
            labels:
              workflows.argoproj.io/test: nextflow-hello
          spec:
            entrypoint: nextflow-hello
            ttlStrategy:
              secondsAfterCompletion: 300  # Clean up after 5 minutes
            
            templates:
            - name: nextflow-hello
              container:
                image: nextflow/nextflow:23.10.0
                command: ["/bin/bash"]
                args:
                  - -c
                  - |
                    echo "=== Nextflow Hello World Workflow Test ==="
                    echo "Nextflow version:"
                    nextflow -version
                    
                    echo "Creating simple hello world script..."
                    cat > hello.nf << 'NFEOF'
                    #!/usr/bin/env nextflow
                    
                    process sayHello {
                        input:
                        val x
                        
                        output:
                        stdout
                        
                        script:
                        """
                        echo "Hello World from Nextflow! Input: $x"
                        echo "Current date: \$(date)"
                        echo "Hostname: \$(hostname)"
                        """
                    }
                    
                    workflow {
                        Channel.of('CI-Test', 'Argo-Workflows', 'Kind-Cluster') | sayHello | view
                    }
                    NFEOF
                    
                    echo "Running Nextflow hello world workflow..."
                    nextflow run hello.nf
                    
                    echo "=== Workflow completed successfully! ==="
                
                resources:
                  requests:
                    memory: "512Mi"
                    cpu: "200m"
                  limits:
                    memory: "1Gi"
                    cpu: "500m"
                
                env:
                - name: NXF_HOME
                  value: "/tmp/.nextflow"
          EOF

      - name: Create workflow test script
        run: |
          cat > test-workflows/test_nextflow_execution.py << 'EOF'
          #!/usr/bin/env python3
          """Test script to submit and monitor Nextflow workflow execution."""
          
          import requests
          import yaml
          import time
          import json
          import sys
          from typing import Dict, Any
          
          class ArgoWorkflowTester:
              def __init__(self, base_url: str = "http://localhost:2746"):
                  self.base_url = base_url
                  self.api_url = f"{base_url}/api/v1"
                  
              def submit_workflow(self, workflow_yaml: str) -> Dict[str, Any]:
                  """Submit a workflow to Argo Workflows."""
                  with open(workflow_yaml, 'r') as f:
                      workflow_spec = yaml.safe_load(f)
                  
                  url = f"{self.api_url}/workflows/argo-workflows"
                  headers = {'Content-Type': 'application/json'}
                  
                  print(f"Submitting workflow to {url}")
                  response = requests.post(url, json=workflow_spec, headers=headers)
                  
                  if response.status_code == 201:
                      workflow = response.json()
                      print(f"✓ Workflow submitted successfully: {workflow['metadata']['name']}")
                      return workflow
                  else:
                      print(f"✗ Failed to submit workflow: {response.status_code}")
                      print(f"Response: {response.text}")
                      raise Exception(f"Workflow submission failed: {response.status_code}")
              
              def get_workflow_status(self, namespace: str, name: str) -> Dict[str, Any]:
                  """Get workflow status."""
                  url = f"{self.api_url}/workflows/{namespace}/{name}"
                  response = requests.get(url)
                  
                  if response.status_code == 200:
                      return response.json()
                  else:
                      raise Exception(f"Failed to get workflow status: {response.status_code}")
              
              def wait_for_completion(self, namespace: str, name: str, timeout: int = 300) -> Dict[str, Any]:
                  """Wait for workflow to complete."""
                  start_time = time.time()
                  
                  while time.time() - start_time < timeout:
                      try:
                          workflow = self.get_workflow_status(namespace, name)
                          phase = workflow.get('status', {}).get('phase', 'Unknown')
                          
                          print(f"Workflow {name} status: {phase}")
                          
                          if phase in ['Succeeded', 'Failed', 'Error']:
                              return workflow
                          
                          time.sleep(10)
                      except Exception as e:
                          print(f"Error checking workflow status: {e}")
                          time.sleep(5)
                  
                  raise Exception(f"Workflow did not complete within {timeout} seconds")
              
              def test_nextflow_hello_world(self) -> bool:
                  """Test Nextflow hello world workflow execution."""
                  try:
                      print("🚀 Starting Nextflow Hello World test...")
                      
                      # Submit workflow
                      workflow = self.submit_workflow('test-workflows/nextflow-hello-world.yaml')
                      namespace = workflow['metadata']['namespace']
                      name = workflow['metadata']['name']
                      
                      # Wait for completion
                      print(f"⏳ Waiting for workflow {name} to complete...")
                      final_workflow = self.wait_for_completion(namespace, name)
                      
                      # Check result
                      phase = final_workflow.get('status', {}).get('phase', 'Unknown')
                      
                      if phase == 'Succeeded':
                          print("✅ Nextflow Hello World workflow completed successfully!")
                          
                          # Try to get logs
                          try:
                              logs_url = f"{self.api_url}/workflows/{namespace}/{name}/log"
                              logs_response = requests.get(logs_url)
                              if logs_response.status_code == 200:
                                  print("📋 Workflow logs:")
                                  print(logs_response.text)
                          except Exception as e:
                              print(f"Could not retrieve logs: {e}")
                          
                          return True
                      else:
                          print(f"❌ Workflow failed with phase: {phase}")
                          
                          # Print failure details
                          if 'status' in final_workflow and 'message' in final_workflow['status']:
                              print(f"Error message: {final_workflow['status']['message']}")
                          
                          return False
                          
                  except Exception as e:
                      print(f"❌ Test failed with exception: {e}")
                      return False
          
          def main():
              print("🧪 Nextflow Workflow Execution Test")
              print("===================================")
              
              # Test connectivity to Argo Workflows
              try:
                  response = requests.get("http://localhost:2746/", timeout=10)
                  print(f"✓ Argo Workflows API accessible (status: {response.status_code})")
              except Exception as e:
                  print(f"✗ Cannot access Argo Workflows API: {e}")
                  sys.exit(1)
              
              # Run the test
              tester = ArgoWorkflowTester()
              success = tester.test_nextflow_hello_world()
              
              if success:
                  print("\n🎉 All tests passed!")
                  sys.exit(0)
              else:
                  print("\n💥 Tests failed!")
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          EOF
          
          chmod +x test-workflows/test_nextflow_execution.py

      - name: Run Nextflow workflow test
        run: |
          echo "Running Nextflow workflow execution test..."
          python test-workflows/test_nextflow_execution.py

      - name: Check final cluster state
        run: |
          echo "=== Final cluster state ==="
          kubectl get workflows -n argo-workflows
          kubectl get pods -n argo-workflows
          
          echo "=== Workflow events ==="
          kubectl get events -n argo-workflows --sort-by=.metadata.creationTimestamp || true

      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up port forwards..."
          pkill -f "kubectl port-forward" || true
          
          echo "Cleaning up completed workflows..."
          kubectl delete workflows -n argo-workflows -l workflows.argoproj.io/test=nextflow-hello --ignore-not-found=true || true